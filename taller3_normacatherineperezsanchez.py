# -*- coding: utf-8 -*-
"""Taller3_NormaCatherinePerezSanchez.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1TpgiZhEEsoC_KPfhuhEcG3F0FMykd8cB

# Python en un contexto de Negocio de aerolineas (Caso practico)

**Contexto empresarial.** Es un empleado de GrowthAir, una compañía aérea comercial en crecimiento. En los últimos años, GrowthAir ha expandido los servicios de vuelos de lujo a ubicaciones en todo el mundo. Tras el excelente desempeño de su equipo en la identificación de nuevas oportunidades comerciales el año pasado, se le ha encomendado la tarea de identificar los principales países para expandir aún más el servicio de vuelos de lujo de GrowthAir.

**Problema empresarial.** Su gerente le ha pedido que responda a la siguiente pregunta: "¿En qué países debería GrowthAir expandir su servicio de vuelos de lujo?"

**Contexto analítico.** Los datos relevantes son una serie de estimaciones de éxito (es decir, probabilidades de éxito) que han elaborado sus equipos internos de investigación de mercados. Usando su capacidad para realizar análisis de datos en Python, se embarcará en resumir las estimaciones de éxito disponibles para producir una recomendación concisa para su jefe.
"""

#Datos sobre la probabilidad de éxito de la expansión por estimaciones de países
success_estimates = {'Australia': [0.6, 0.33, 0.11, 0.14],
                     'France': [0.66, 0.78, 0.98, 0.2],
                     'Italy': [0.6],
                     'Brazil': [0.22, 0.22, 0.43],
                     'USA': [0.2, 0.5, 0.3],
                     'England': [0.45],
                     'Canada': [0.25, 0.3],
                     'Argentina': [0.22],
                     'Greece': [0.45, 0.66, 0.75, 0.99, 0.15, 0.66],
                     'Morocco': [0.29],
                     'Tunisia': [0.68, 0.56],
                     'Egypt': [0.99],
                     'Jamaica': [0.61, 0.65, 0.71],
                     'Switzerland': [0.73, 0.86, 0.84, 0.51, 0.99],
                     'Germany': [0.45, 0.49, 0.36]};

print(success_estimates)

"""Observe el reordenamiento de los elementos del diccionario cuando imprimimos en comparación con el orden en el que originalmente definimos el diccionario. Este es un aspecto clave de los tipos de datos de diccionario: ¡están desordenados! (Esto es muy diferente en comparación con los tipos de datos de lista, que están ordenados.).

Ahora intuitivamente, nos gustaría recomendar que la empresa se esfuerce en el país con la estimación de éxito más alta. Pero, ¿qué significa esto cuando hay múltiples estimaciones de éxito para algunos países y solo una para otros? Exploraremos esto a continuación.


# Interactuemos con los diccionarios y listas

Si observa detenidamente el diccionario ```success_estimates```, verá que algunos países solo tienen una estimación de éxito, mientras que otros tienen muchas. Por ejemplo, Inglaterra solo tiene una estimación en su lista [0,45], mientras que Jamaica tiene tres estimaciones en su lista [0,61, 0,65, 0,71]. Acerquémonos a Jamaica y echemos un vistazo a algunas estadísticas resumidas de las estimaciones.

En Python, el tipo de diccionario tiene métodos incorporados (funciones, que discutiremos más adelante) para acceder a las claves y valores del diccionario. Estos métodos se llaman escribiendo  ```.keys()``` o ```.values ()``` después del objeto dictonary. Cambiaremos el tipo de retorno de las llamadas ```.keys()``` y ```.values()``` a una lista utilizando el método ```list()```.
"""

list(success_estimates.keys())

list(success_estimates.values())

"""Haremos uso del acceso a las llaves primarias y valores de un diccionario más adelante en el caso al comparar las estimaciones de numerosos países. Por ahora, recuerde que puede acceder a la lista completa de llaves primarias o valores de un diccionario simplemente llamando a los métodos integrados.

# Ejercicio 1
También nos gustaría comprobar si el nombre de un país es una de las claves del diccionario. Verificar si Morocco y Japan se encuentran en ``success_estimates``

De ser asi obtener la lista de valores para Morocco y Japan

"""

if "Morocco" in success_estimates:
  print('Morocco', success_estimates['Morocco'])
else:
  print("Morocco no existe en success_estimates")

if "Japan" in success_estimates:
  print('Japan',success_estimates['Japan'])
else:
  print("Japan no existe en success_estimates")

"""# Ejercicio 2
Imprimir la longitud de las listas de estimaciones de éxito para Francia, Grecia y Marruecos.

"""

francia = len(success_estimates['France'])
Grecia = len(success_estimates['Greece'])
morocco = len(success_estimates['Morocco'])
print("La longitud de France es: ", francia)
print("La longitud de Greece es: ", Grecia)
print("La longitud de Morocco es: ", morocco)

"""# Ejercicio 3

¿Cuál de las siguientes opciones sería útil para almacenar estimaciones de éxito del proyecto si estuvieran disponibles a nivel regional en lugar de a nivel nacional?

(a) Lista

***(b) Diccionario*** 

(c) Flotantes

(d) Cadena

## Calcular una estimación de éxito promedio específica de un país

Continuando con nuestro análisis sobre Jamaica, la lista contiene tres números, [0,61, 0,65, 0,71]. Recuerde que estos números son del tipo ```float``` en Python, que almacena valores decimales numéricos. Una forma lógica de resumir estas estimaciones para poder compararlas entre países es utilizar el promedio aritmético. Usemos operadores artiméticos básicos para calcular la estimación de éxito promedio para Jamaica, almacenando el resultado en una nueva variable ```avg_jamaica```:
"""

avg_jamaica = (0.61 + 0.65 + 0.71) / 3
print(avg_jamaica)

"""Vemos que la probabilidad promedio de éxito estimada para Jamaica es de aproximadamente 0.657. Sin embargo, producimos esta estimación codificando manualmente los valores. Si hiciéramos esto para todos los países, llevaría bastante tiempo. Por eso, nos gustaría utilizar una forma más automatizada de producir el promedio.

Para producir un promedio, podemos utilizar una <b>función</b>. Las funciones operan sobre datos y variables en Python para realizar una acción deseada. Las funciones pueden tener tanto <b> entradas </b> como <b> salidas </b>, al igual que los operadores matemáticos familiares como suma, resta, multiplicación y división (que tienen dos entradas y una salida). Si bien las funciones en Python aún pueden tener un propósito matemático, como elevar al cuadrado un número entero, Python permite un comportamiento de función más abstracto, como imprimir en la pantalla. En este caso, la función ```print()``` imprimirá su entrada en la pantalla.
"""

country_name = 'Jamaica'
jamaica_list = success_estimates[country_name] # lista de estimacione spara jamaica
print(jamaica_list)

avg_jamaica = sum(jamaica_list) / len(jamaica_list)
min_jamaica = min(jamaica_list)
max_jamaica = max(jamaica_list)
print("Pais:",country_name,", Average:",avg_jamaica)
print("Pais:",country_name,", Min:",min_jamaica)
print("Pais:",country_name,", Max:",max_jamaica)

# Ahora redondeando
avg_jamaica = round(sum(jamaica_list) / len(jamaica_list),2)
min_jamaica = round(min(jamaica_list),2)
max_jamaica = round(max(jamaica_list),2)
print("Pais:",country_name,", Average:",avg_jamaica)
print("Pais:",country_name,", Min:",min_jamaica)
print("Pais:",country_name,", Max:",max_jamaica)

"""Escribamos un código para calcular el éxito promedio de cada país. Muestra (usando print ()) la estimación de éxito promedio de cada país en la pantalla. Las declaraciones impresas deben mostrar cada país en una nueva línea, por ejemplo:"""

print("Pais:",'France',", Average:",sum(success_estimates['France']) / len(success_estimates['France']))
print("Pais:",'Brazil',", Average:",sum(success_estimates['Brazil']) / len(success_estimates['Brazil']))
print("Pais:",'Argentina',", Average:",sum(success_estimates['Argentina']) / len(success_estimates['Argentina']))
print("Pais:",'Germany',", Average:",sum(success_estimates['Germany']) / len(success_estimates['Germany']))
print("Pais:",'Australia',", Average:",sum(success_estimates['Australia']) / len(success_estimates['Australia']))
print("Pais:",'Canada',", Average:",sum(success_estimates['Canada']) / len(success_estimates['Canada']))
print("Pais:",'Greece',", Average:",sum(success_estimates['Greece']) / len(success_estimates['Greece']))
print("Pais:",'USA',", Average:",sum(success_estimates['USA']) / len(success_estimates['USA']))
print("Pais:",'Switzerland',", Average:",sum(success_estimates['Switzerland']) / len(success_estimates['Switzerland']))
print("Pais:",'Tunisia',", Average:",sum(success_estimates['Tunisia']) /len(success_estimates['Tunisia']))
print("Pais:",'Italy',", Average:",sum(success_estimates['Italy']) / len(success_estimates['Italy']))
print("Pais:",'Egypt',", Average:",sum(success_estimates['Egypt']) / len(success_estimates['Egypt']))
print("Pais:",'Jamaica',", Average:",sum(success_estimates['Jamaica']) / len(success_estimates['Jamaica']))
print("Pais:",'Morocco',", Average:",sum(success_estimates['Morocco']) / len(success_estimates['Morocco']))
print("Pais:",'England',", Average:",sum(success_estimates['England']) / len(success_estimates['England']))

"""## Determinar sistemáticamente la estimación de éxito promedio para todos los países

El objetivo final de este análisis es una recomendación sobre dónde se deben considerar las oportunidades de expansión global. Para llegar a una conclusión, sería ideal tener la probabilidad de éxito promedio para cada país.

Para lograr esto, usaremos un elemento de flujo de control en Python: el <b> bucle for </b>. El bucle ```for``` permite ejecutar las mismas declaraciones una y otra vez (es decir, en bucle). Esto ahorra una cantidad significativa de tiempo codificando tareas repetitivas y ayuda en la legibilidad del código. La estructura general de un bucle for es:

```python
for iterator_variable in some_sequence:
    statements(s)
```

The for loop iterates over ```some_sequence``` and performs ```statements(s)``` at each iteration. That is, at each iteration the ```iterator_variable```  is updated to the next value in ```some_sequence```. As a concrete example, consider the loop:

```python
for i in [1,2,3,4]:
    print(i*i)
```

Aquí, el bucle for se imprimirá en la pantalla cuatro veces; es decir, imprimirá ```1``` en la primera iteración del ciclo,```4``` en la segunda iteración,```9``` en la tercera y ```16``` en el cuarto. Por lo tanto, la instrucción de bucle for iterará sobre todos los elementos de la lista ```[1,2,3,4]```, y en cada iteración actualiza la variable iteradora ```i``` a la siguiente valor en la lista ```[1,2,3,4]```.

Usemos un ciclo for en los datos de nuestro país obteniendo una lista de todas las claves en ```success_estimates```:

"""

country_name_list = list(success_estimates.keys())
print(country_name_list)

"""Aquí podemos recorrer todos los elementos en ```country_name_list```, extraemos el valor correspondiente de ```success_estimates``` (que será del tipo list), y posteriormente tomamos la media de la lista. La impresión detallada lo guiará a través de la ejecución del bucle for.

# Ejericicio 4

Crear un loop que obtenga e imprima el promedio de la tasa de exito de cada pais
"""

for x, y in success_estimates.items():
  avg_x = round(sum(success_estimates[x]) / len(success_estimates[x]),2)
  print("- {0} tiene Promedio:".format(x), avg_x)

"""# Ejercicio 5
Escribir un bucle for para calcular el mínimo y el máximo de la lista de estimaciones de éxito de cada país, imprimiendo cada uno de forma consecutiva como en el ejemplo de bucle for anterior.
"""

#Datos sobre la probabilidad de éxito de la expansión por estimaciones de países
success_estimates = {'Australia': [0.6, 0.33, 0.11, 0.14],
                     'France': [0.66, 0.78, 0.98, 0.2],
                     'Italy': [0.6],
                     'Brazil': [0.22, 0.22, 0.43],
                     'USA': [0.2, 0.5, 0.3],
                     'England': [0.45],
                     'Canada': [0.25, 0.3],
                     'Argentina': [0.22],
                     'Greece': [0.45, 0.66, 0.75, 0.99, 0.15, 0.66],
                     'Morocco': [0.29],
                     'Tunisia': [0.68, 0.56],
                     'Egypt': [0.99],
                     'Jamaica': [0.61, 0.65, 0.71],
                     'Switzerland': [0.73, 0.86, 0.84, 0.51, 0.99],
                     'Germany': [0.45, 0.49, 0.36]};

#Solución
listaPaises = list(success_estimates.keys())
for x in listaPaises: 
  print('- {0} tiene un mínimo de {1} y un máximo de {2}'.format(x, min(success_estimates[x]), max(success_estimates[x])))

"""# Ejercicio 6
Escriba el código para determinar el país con el mayor rango de estimaciones de éxito (es decir, la mayor diferencia entre la estimación más pequeña y la más grande para un país).
"""

#Datos sobre la probabilidad de éxito de la expansión por estimaciones de países
success_estimates = {'Australia': [0.6, 0.33, 0.11, 0.14],
                     'France': [0.66, 0.78, 0.98, 0.2],
                     'Italy': [0.6],
                     'Brazil': [0.22, 0.22, 0.43],
                     'USA': [0.2, 0.5, 0.3],
                     'England': [0.45],
                     'Canada': [0.25, 0.3],
                     'Argentina': [0.22],
                     'Greece': [0.45, 0.66, 0.75, 0.99, 0.15, 0.66],
                     'Morocco': [0.29],
                     'Tunisia': [0.68, 0.56],
                     'Egypt': [0.99],
                     'Jamaica': [0.61, 0.65, 0.71],
                     'Switzerland': [0.73, 0.86, 0.84, 0.51, 0.99],
                     'Germany': [0.45, 0.49, 0.36]};

#Solución
rango = {}
for pais, esti in success_estimates.items():
  nombre_pais = pais
  pais_list = success_estimates[nombre_pais]
  max_pais = max(pais_list)
  min_pais = min(pais_list)
  rango[nombre_pais] = [max_pais-min_pais]
  maxi_pais = max(rango.values())

for x, y in rango.items():
  if (y == maxi_pais):
    print('El pais con el mayor rango de estimacion de exito es {0} con {1}'.format(x,y))

"""## Uso de listas por comprensión para determinar la cantidad de estimaciones para cada país

En el futuro, estamos interesados en conocer la cantidad de estimaciones de éxito disponibles para cada país. Python ofrece una forma concisa de lograr este objetivo mediante el uso de <b> listas por comprensión </b>.

Las listas por comprensión le permiten a uno construir una lista de manera concisa. Echemos un vistazo a cómo funciona esto.
"""

key_name_list = [i for i in success_estimates] # loop sobre cada item  i en success_estimates y ponerlo en una lista
key_name_list

"""Aquí vemos que hemos hecho un bucle sobre cada clave del diccionario success_estimates (por lo tanto, cada país) y extraído el nombre del país, todo en una línea de código. También podemos acceder a los valores de cada clave en success_estimates."""

value_name_list = [success_estimates[i] for i in success_estimates] # loop sobre cada item i ensuccess_estimates y poner success_estimates[i] en la lista
value_name_list

"""En la lista por comprensión anterior, cada valor de ```i``` es un nombre de país y el valor se devuelve cuando se llama a ```success_estimates [i]```. Vemos que esto es una forma efectiva y concisa de escribir un bucle for que crea una lista.

Podemos usar esto para determinar rápidamente cuántas estimaciones de éxito están disponibles para cada país.
"""

[[i,len(success_estimates[i])] for i in success_estimates]

"""# Ejercicio 7
Utilizando listas por comprensión, escriba un script para crear una <b> lista de listas </b> llamada ```sum_squares_list```, donde cada elemento de la lista es una lista de dos elementos [nombre del país, valor]. El elemento de valor en la lista debe ser la suma de cuadrados de las estimaciones de éxito de ese país. Por ejemplo, un elemento de ```sum_squares_list``` debe ser para Jamaica, donde la lista de dos elementos es [Jamaica, 1.2987] (desde 1.2987 = 0.61^ 2 + 0.65^ 2 + 0.71^ 2).
"""

sum_squares_list = [[x, sum([valor**2 for valor in success_estimates[x]])] for x in success_estimates]
sum_squares_list

"""# Ejercicio 8
Nos gustaría determinar la distribución alrededor de la estimación de éxito promedio para cada país. Utilizando listas por comprensión, escriba un codigo que reste la estimación de éxito promedio para un país determinado de cada estimación de éxito para ese país. Almacene los resultados en una lista llamada ```remove_mean_list```. Redondea los valores a dos decimales. Su salida debe producir la siguiente lista de listas:


```
[['Australia', [0.3, 0.03, -0.19, -0.16]],
 ['France', [0.01, 0.12, 0.32, -0.46]],
 ['Italy', [0.0]],
 ['Brazil', [-0.07, -0.07, 0.14]],
 ['USA', [-0.13, 0.17, -0.03]],
 ['England', [0.0]],
 ['Canada', [-0.03, 0.02]],
 ['Argentina', [0.0]],
 ['Greece', [-0.16, 0.05, 0.14, 0.38, -0.46, 0.05]],
 ['Morocco', [0.0]],
 ['Tunisia', [0.06, -0.06]],
 ['Egypt', [0.0]],
 ['Jamaica', [-0.05, -0.01, 0.05]],
 ['Switzerland', [-0.06, 0.07, 0.05, -0.28, 0.2]],
 ['Germany', [0.02, 0.06, -0.07]]]
```
"""

import numpy 
remove_mean_list = [[x, [round(valor-numpy.mean(success_estimates[x]),2) for valor in success_estimates[x]]] for x in success_estimates]
remove_mean_list

"""Según el análisis anterior, vemos que las estimaciones de éxito medio de los países varían ampliamente, desde el más bajo, Canadá = 0,275, hasta el más alto, Egipto = 0,99. Sin embargo, observe que la media de Egipto se calcula a partir de 1 estimación de éxito. ¿Confiamos en confiar en una única estimación como proxy de la estimación de éxito promedio?

Dado que el proyecto de expansión global utilizará valiosos recursos de la empresa, decidimos que es mejor restringir nuestro análisis a países que tienen dos o más estimaciones de éxito. Para realizar esta tarea, usaremos una estructura de control en Python conocida como la <b> instrucción if ... elif ... else </b>. Sigue la estructura general.


```python
if test_expression_1:
    block1_statement(s)
elif test_expression_2:
    block2_statement2(s)
else:
    block3_statement(s)
```

Aquí, ```test_expression_1``` y ```test_expression_2``` deben evaluarse como ```True``` o ```False```, un tipo <b>booleano</b> de Python. El tipo booleano está asociado con variables que son ```Verdadero``` o ```Falso```.

Si ```test_expression_1``` es True, ```block1_statement(s)``` se ejecutará y las otras sentencias de bloque no. Si ```test_expression_1``` es False pero ```test_expression_2``` es True, entonces ```block2_statement2 (s)``` se ejecutará y los demás no. Finalmente, si ```test_expression_1``` y ``` test_expression_2``` son ambos falsos, entonces se ejecutará el ```block3_statement (s)``` de la sección else. Esta estructura condicional de una declaración if permite controlar el flujo del código Python.

Usemos esto para filtrar los países que solo tienen una estimación de éxito.

# Ejercicio 9
Usaremos la declaración if anterior para eliminar los países con menos de una estimación de éxito. Para facilitar la visualización del resultado, almacenaremos las estimaciones medias de cada país en un nuevo diccionario ```country_means```.
"""

country_means=[]
for i in country_name_list:
  if len(success_estimates[i])>1:
    promedio = sum(success_estimates[i])/len(success_estimates[i])
    country_means.append([i,round(promedio,2)])

country_means

"""Al observar las medias de países resultantes, notamos que el país con la mayor estimación de éxito medio es Suiza con 0,79, mientras que la estimación de éxito medio más baja es Canadá con 0,28.

# Ejercicio 10
Después de revisar la política de la empresa sobre procedimientos estadísticos, observa que la empresa recomienda que todas las estimaciones (promedios, mínimos, máximos) deben tener al menos tres valores que contribuyan a la estadística de resumen. Escriba un ciclo for y use la estructura de la declaración if para seleccionar e imprimir las estimaciones de éxito promedio para los países que cumplen con esta política. Si el país no cumple con la política, escriba el nombre del país y "*No cumple con la política de la empresa*". Cada país debería aparecer en una nueva línea.
"""

import numpy
for x in list(success_estimates.keys()):
  if len(success_estimates[x]) >= 3:
    print('- {0} cumple con la política de la empresa, con un promedio: {1}.'.format(x, round(numpy.mean(success_estimates[x]),2)))
  else: 
    print('- {0} no cumple con la politica de la empresa.'.format(x))

"""# Ejercicio 11
¿Cuál es otro enfoque para mejorar el problema de una muestra en algunos países? Piense en términos de los factores que impulsan la confianza en las decisiones comerciales basadas en datos.

(a) Agrupe los países en regiones más grandes para asegurarse de que cada región tenga al menos una estimación

(b) Solo elimine un país si sus estimaciones son muy grandes o muy pequeñas en comparación con otras estimaciones.

(c) Utilice una estadística de resumen diferente para el análisis que no sea el valor promedio.

***(d) Revise por qué algunos países solo tienen una estimación y vea si se pueden obtener más datos para estos países.***

Hemos utilizado bucles y estructuras de control para calcular estadísticas resumidas parciales para cada uno de los países. Pongamos todo junto para obtener una recomendación sobre qué país deberíamos elegir para ampliar los servicios de vuelos de lujo.

# Ejercicio 12
Escriba el código para imprimir el nombre de cada país y las estadísticas resumidas. Cada línea debe mostrar un país y las estadísticas resumidas correspondientes: Estimación mínima (flotante), Estimación promedio (flotante), Estimación máxima (flotante), Número de estimaciones (int), Cumple con la política de la empresa de al menos 3 estimaciones (bool). Por ejemplo, la línea para Francia aparecería como:

```
Country: France , Min: 0.2 , Average: 0.655 , Max: 0.98 , NumEst: 4 , MeetsPolicy: True
```
"""



"""#Conclusiones"""